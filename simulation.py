import numpy as np
from point_object import PointObject
from center_object import CenterObject
from PIL import Image, ImageDraw
from copy import copy


class Simulation:
    def __init__(self, resolution: tuple[int, int], meters_per_pixel: float,
                 center_obj: CenterObject, point_objs: list[PointObject]):
        self._resolution = resolution
        self._meters_per_pixel = meters_per_pixel

        self._center_obj = center_obj
        self._point_objs = point_objs

        self._G_CONST = 6.67430e-11
        self._TIME_STEP = 1

        self._CENTER_OBJ_FILL = (255, 255, 255)
        self._POINT_OBJ_FILL = (0, 255, 0)
        self._POINT_OBJ_END = (255, 0, 0)

    def calculate_next(self, point_obj: PointObject) -> np.array:
        """Runs the simulation for a single step for a specific PointObject.
        Modifies its position and velocity, and returns a copy of the new position.
        """
        dist_vector = self._center_obj.position - point_obj.position
        dist = np.linalg.norm(dist_vector)
        dist_norm = dist_vector / dist

        force = (self._center_obj.mass * point_obj.mass * self._G_CONST) / (dist**2)
        force_vector = force * dist_norm
        accel_vector = force_vector / point_obj.mass

        point_obj.update_position(self._TIME_STEP)
        point_obj.set_velocity(point_obj.velocity + (accel_vector * self._TIME_STEP))
        return copy(point_obj.position)

    def run(self, steps: int) -> tuple[list[list[np.array]],
                                       list[tuple[int, list[int]]]]:
        """Run the simulation with all the previously set values
        Args:
            steps: The amount of steps of the simulation to run
        Returns:
            A tuple, where the first element is a list of positions per step.
            So accessing the position of the third PointObject at the second step
            would look like: run(10)[0][1][2]

            The second element of the tuple is a collision report.
            It's a list of all collisions, each represented by a tuple,
            where the first element is the simulation step at which it took place
            and the second is a list of indexes of PointObjects which collided.
        """
        sim_steps = [[(obj.position / self._meters_per_pixel).round()
                       for obj in self._point_objs]]
        collisions = []
        blacklist = []
        for step in range(steps):
            positions = [np.array([np.nan, np.nan])] * len(self._point_objs)
            for index in range(len(self._point_objs)):
                if index not in blacklist:
                    pos = self.calculate_next(self._point_objs[index])
                    dist_to_center = np.linalg.norm(self._center_obj.position - pos)
                    if dist_to_center > self._center_obj.diameter / 2:
                        positions[index] = (pos / self._meters_per_pixel).round()
                    else:
                        collisions.append((step, [index]))
                        blacklist.append(index)

            _, inverse, count = np.unique(positions, return_inverse=True,
                                          return_counts=True, axis=0)
            duplicate_indexes = np.where(count[inverse] > 1)[0]
            if len(duplicate_indexes) > 0:
                collisions.append((step, duplicate_indexes))
            blacklist.extend(duplicate_indexes)

            sim_steps.append(positions)
        return sim_steps, collisions

    def draw(self, simulation_steps: list[list[np.array]]) -> Image.Image:
        """Generates an image based on the given simulation_steps (which should be
        generated by run()) and saves it to a file if file_name was set
        """
        output = Image.new("RGB", self._resolution)
        draw_output = ImageDraw.Draw(output)

        pixel_radius = round((self._center_obj.diameter / 2) / self._meters_per_pixel)
        img_center = [round(self._resolution[0] / 2), round(self._resolution[1] / 2)]
        draw_output.circle(img_center, pixel_radius, fill=self._CENTER_OBJ_FILL)

        for step in simulation_steps:
            for obj_pos in step:
                if obj_pos is not np.nan:
                    obj_pos[1] *= -1  # Y axis has to be inverted
                    # This is because on the image it rises the lower it goes, which
                    # is the opposite of how it works in 2D geometry
                    draw_output.point(tuple(img_center + obj_pos),
                                      self._POINT_OBJ_FILL)

        for obj in self._point_objs:
            obj_pos = obj.position * np.array([1, -1])  # Invert Y axis
            pos = img_center + (obj_pos / self._meters_per_pixel).round()
            draw_output.point(tuple(pos), self._POINT_OBJ_END)

        return output

    @staticmethod
    def generate_collision_report(collision_data) -> str:
        """Presents the given collision data in a readable format"""
        output = ""
        for collision in collision_data:
            if len(collision[1]) > 1:
                objects = ""
                for obj in collision[1]:
                    objects += f"n={obj}, "
                output += f"Objects {objects[:-2]} collided at k={collision[0]}\n"
            else:
                output += f"Object n={collision[1][0]} collided at k={collision[0]}\n"

        return output
