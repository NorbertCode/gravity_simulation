import json
import numpy as np
from point_object import PointObject
from center_object import CenterObject
from PIL import Image, ImageDraw
from copy import copy


class Simulation:
    G_CONST = 6.67430e-11
    TIME_STEP = 1

    def __init__(self, resolution: tuple[int, int], meters_per_pixel: float):
        """Constructor, which only sets simulation configuration.
        Use init_objects() or init_from_json() to initialize simulation values.
        """
        self._resolution = resolution
        self._meters_per_pixel = meters_per_pixel

        # Colors to use in simulation output
        self._center_obj_fill_color = (255, 255, 255)
        self._point_obj_fill_color = (0, 255, 0)
        self._point_obj_end_color = (255, 0, 0)

    def init_objects(self, center_obj: CenterObject, point_objs: list[PointObject]):
        self._center_obj = center_obj
        self._point_objs = point_objs

    def init_from_json(self, data):
        center_obj = CenterObject(data["center_object"]["diameter"],
                                  data["center_object"]["mass"])
        point_objs = [
            PointObject(np.array(obj["position"]),
                        obj["mass"],
                        np.array(obj["velocity"]))
            for obj in data["point_objects"]
        ]
        self.init_objects(center_obj, point_objs)

    def save_as_json(self, path: str, center_obj: CenterObject,
                     point_objs: list[PointObject]):
        data = {
            "center_object": {
                "diameter": center_obj.diameter,
                "mass": center_obj.mass
            },
            "point_objects": [
                {
                    "velocity": obj.velocity.tolist(),
                    "mass": obj.mass,
                    "position": obj.position.tolist()
                }
                for obj in point_objs
            ]
        }
        with open(path, "w") as file:
            json.dump(data, file, indent=4)

    def calculate_next(self, point_obj: PointObject) -> np.array:
        """Runs the simulation for a single step for a specific PointObject.
        Modifies its position and velocity, and returns a copy of the new position.
        """
        dist_vector = self._center_obj.position - point_obj.position
        dist = np.linalg.norm(dist_vector)
        dist_norm = dist_vector / dist

        force = (self._center_obj.mass * point_obj.mass * self.G_CONST) / (dist**2)
        force_vector = force * dist_norm
        accel_vector = force_vector / point_obj.mass

        point_obj.update_position(self.TIME_STEP)
        point_obj.set_velocity(point_obj.velocity + (accel_vector * self.TIME_STEP))
        return copy(point_obj.position)

    def run(self, steps: int) -> tuple[list[list[np.array]],
                                       list[tuple[int, list[int]]]]:
        """Run the simulation with all the previously set values
        Args:
            steps: The amount of steps of the simulation to run
        Returns:
            A tuple, where the first element is a list of positions per step.
            So accessing the position of the third PointObject at the second step
            would look like: run(10)[0][1][2]

            The second element of the tuple is a collision report.
            It's a list of all collisions, each represented by a tuple,
            where the first element is the simulation step at which it took place
            and the second is a list of indexes of PointObjects which collided.
        """
        sim_steps = [[(obj.position / self._meters_per_pixel).round()
                       for obj in self._point_objs]]
        collisions = []
        blacklist = []
        for step in range(steps):
            positions = [np.array([np.nan, np.nan])] * len(self._point_objs)
            for index in range(len(self._point_objs)):
                if index not in blacklist:
                    pos = self.calculate_next(self._point_objs[index])
                    dist_to_center = np.linalg.norm(self._center_obj.position - pos)
                    if dist_to_center > self._center_obj.diameter / 2:
                        positions[index] = (pos / self._meters_per_pixel).round()
                    else:
                        collisions.append((step, [index]))
                        blacklist.append(index)

            _, inverse, count = np.unique(positions, return_inverse=True,
                                          return_counts=True, axis=0)
            duplicate_indexes = np.where(count[inverse] > 1)[0]
            if len(duplicate_indexes) > 0:
                collisions.append((step, duplicate_indexes))
            blacklist.extend(duplicate_indexes)

            sim_steps.append(positions)
        return sim_steps, collisions

    def draw(self, simulation_steps: list[list[np.array]]) -> Image.Image:
        """Generates an image based on the given simulation_steps (which should be
        generated by run()) and saves it to a file if file_name was set
        """
        output = Image.new("RGB", self._resolution)
        draw_output = ImageDraw.Draw(output)

        pixel_radius = round((self._center_obj.diameter / 2) / self._meters_per_pixel)
        img_center = [round(self._resolution[0] / 2), round(self._resolution[1] / 2)]
        draw_output.circle(img_center, pixel_radius, fill=self._center_obj_fill_color)

        for step in simulation_steps:
            for obj_pos in step:
                if obj_pos is not np.nan:
                    obj_pos[1] *= -1  # Y axis has to be inverted
                    # This is because on the image it rises the lower it goes, which
                    # is the opposite of how it works in 2D geometry
                    draw_output.point(tuple(img_center + obj_pos),
                                      self._point_obj_fill_color)

        for obj in self._point_objs:
            obj_pos = obj.position * np.array([1, -1])  # Invert Y axis
            pos = img_center + (obj_pos / self._meters_per_pixel).round()
            draw_output.point(tuple(pos), self._point_obj_end_color)

        return output
        # if file_name is not None:
        #     output.save(f"{file_name}.png")
        # if show_output:
        #     output.show()

    @staticmethod
    def generate_collision_report(collision_data) -> str:
        """Presents the given collision data in a readable format and
        saves it to a file if file_name was set
        """
        output = ""
        for collision in collision_data:
            if len(collision[1]) > 1:
                objects = ""
                for obj in collision[1]:
                    objects += f"n={obj}, "
                output += f"Objects {objects[:-2]} collided at k={collision[0]}\n"
            else:
                output += f"Object n={collision[1][0]} collided at k={collision[0]}\n"

        return output
